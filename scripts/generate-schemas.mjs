import * as fs from "node:fs/promises";
import * as path from "node:path";
import * as url from "node:url";

import camelcase from "camelcase";
import RefParser from "@apidevtools/json-schema-ref-parser";
import { jsonSchemaToZod } from "json-schema-to-zod";

let __dirname = path.dirname(url.fileURLToPath(import.meta.url));

let VERSIONS = ["0.1", "0.2", "0.3", "0.4"];

function inject_additional_required(base, strict) {
  for (let key in strict) {
    if (key === "required") {
      base[key] = (base[key] ?? []).concat(strict[key]);
    } else if (key in base) {
      inject_additional_required(base[key], strict[key]);
    }
  }
}

// This is a hack to resolve the "strict" versions of the schemas for json-schema-to-zod
// It relies on the fact that the "strict" schemas are a superset of the non-strict schemas
// and that the "strict" schemas are defined in terms of the non-strict schemas.
//
// Every strict schema has an "allOf" property with two elements, the first of which is
// the non-strict schema and the second of which is the additional properties that are
// required in the strict schema.
//
// This function takes the "strict" schema and resolves the "allOf" property, then
// injects the additional required properties into the non-strict schema.
async function deref_strict(schema) {
  let root = await RefParser.dereference(schema);
  let [base, additional_required] = root.allOf;
  inject_additional_required(base, additional_required);
  base["$id"] = root["$id"];
  return base;
}

async function ghfetch(endpoint, { token = "" } = {}) {
  let url = new URL(endpoint, "https://api.github.com");
  let auth = `Basic ${Buffer.from(token, "binary").toString("base64")}`;
  let res = await fetch(url, {
    method: "GET",
    headers: { Authorization: auth },
  });
  let data = await res.json();
  if (!res.ok) {
    throw new Error(
      `GitHub request for ${url.pathname} failed. Reason: ${res.statusText} Message: ${data.message}`,
    );
  }
  return data;
}

let src = path.join(__dirname, "..", "src");

await fs.mkdir(src).catch(() => {});

for (let version of VERSIONS) {
  let files = await ghfetch(`/repos/ome/ngff/contents/${version}/schemas`)
    .then((res) => res.filter((f) => f.type === "file"));

  let schemas = await Promise.all(
    files.map((file) =>
      fetch(file.download_url)
        .then((r) => r.json())
        .then((schema) =>
          schema.$id.includes("strict_") ? deref_strict(schema) : schema
        )
    ),
  );

  let exports = schemas.map((schema) => {
    let cased = camelcase(schema.$id.split("/").pop());
    let name = cased.charAt(0).toUpperCase() + cased.slice(1);
    return `export ${jsonSchemaToZod(schema, name, false)}`;
  });

  let module = `// This file is generated by scripts/generate-schemas.mjs\nimport { z } from "zod";\n\n${exports.join("\n\n")}`;

  await fs.writeFile(path.join(src, `${version}.ts`), module);
}

// update package.json

let pkg = JSON.parse(
  await fs.readFile(path.join(__dirname, "..", "package.json"), {
    encoding: "utf8",
  }),
);

pkg.exports = {
  ".": {
    types: `./dist/${VERSIONS.at(-1)}.d.ts`,
    import: `./dist/${VERSIONS.at(-1)}.js`,
  },
};

for (let version of VERSIONS) {
  pkg.exports[`./${version}`] = {
    "types": `./dist/${version}.d.ts`,
    "import": `./dist/${version}.js`,
  };
}

await fs.writeFile(
  path.join(__dirname, "..", "package.json"),
  JSON.stringify(pkg, null, 2),
);
